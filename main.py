# -*- coding: utf-8 -*-
"""Progetto__WatermarkEmbedded.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k7EIez605xp6ep9tyNMfY54QxnkYIjf5

# **Project: Watermarking**

## **Setup**
"""

import numpy as np
import cv2
from matplotlib import pyplot as plt
import copy
import secrets, random
import math
import sys
import pickle
import argparse
import os
np.set_printoptions(threshold=sys.maxsize)

"""***Open Image***"""
def openImage(imgPath, color=None):
    img = None
    path = imgPath
    if color:
        img = cv2.imread(path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    else:
        img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    return img


"""***Show Image***"""


def showImage(image, title):
    if (len(image.shape) == 2):
        plt.imshow(image, cmap='gray', interpolation=None, vmin=0, vmax=255)
    else:
        plt.imshow(image, interpolation=None, vmin=0, vmax=255)
    plt.xticks([]), plt.yticks([])
    plt.show()


"""## **Additional Function**

### **Image Modification**

***Cropping***
"""


def cropLine(img, n):
    imgH, imgW, c = img.shape
    matZy = np.zeros((int(imgH), int(n), 3), dtype=np.uint8)
    matZx = np.zeros((int(n), int(imgW), 3), dtype=np.uint8)

    img[0: int(n), 0: int(imgW)] = matZx
    img[0: int(imgH), 0: int(n)] = matZy
    img[(int(imgH) - int(n)): int(imgH), 0: int(imgW)] = matZx
    img[0: int(imgH), (int(imgW) - int(n)): int(imgW)] = matZy

    return img


def cropLeftHighCorner(img):
    imgH, imgW, c = img.shape
    matZ = np.zeros((int(imgH * 0.5), int(imgW * 0.5), 3), dtype=np.uint8)

    img[0: int(imgW * 0.5), 0: int(imgH * 0.5)] = matZ
    return img


def rotate_image(image, angle):
    image_center = tuple(np.array(image.shape[1::-1]) / 2)
    rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)
    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_NEAREST)
    return result


"""### ***Resize***"""


def resize(im, wat):
    threshold = 0.25;
    imgOut = resizeImage(im, threshold)
    watOut = resizeWatermark(wat, imgOut)

    return imgOut, watOut


"""***Resize Image***"""

sizesImg = [512, 1024, 2048, 4096, 8192]


def getClosest(y):
    return min(sizesImg, key=lambda x: abs(x - y))


def resizeImage(im, threshold=0.25):
    width, height, c = im.shape
    largestDim = max(width, height)
    newDim = max(getClosest(width), getClosest(height))

    if newDim == largestDim:
        return im
    elif newDim < largestDim:
        if (largestDim - newDim) > int(newDim * threshold):
            newDim = sizesImg[sizesImg.index(newDim) + 1]
            imgRes = cv2.resize(im, (newDim, newDim), interpolation=cv2.INTER_CUBIC)
        else:
            imgRes = cv2.resize(im, (newDim, newDim), interpolation=cv2.INTER_LANCZOS4)
    else:
        imgRes = cv2.resize(im, (newDim, newDim), interpolation=cv2.INTER_CUBIC)

    #showImage(imgRes, "Image Resized")
    return imgRes


"""***Resize Watermark***"""


def resizeWatermark(wat, img):
    dimWat = int(img.shape[0] / 16)

    if wat.shape[0] == dimWat:
        return wat
    else:
        watRes = cv2.resize(wat, (dimWat, dimWat), interpolation=cv2.INTER_NEAREST)
        #showImage(watRes, "Watermark Resized")
        return watRes


"""## **Watermark Embedding**

### **STEP 1: Watermark Manipulation**

***Step a: Rounding to binary***
"""


def watermarkRounding(wat):
    watW = wat.shape[0]
    watH = wat.shape[1]

    for i in range(watW):
        for j in range(watH):
            if wat[i, j] < 127.5:
                wat[i, j] = 0
            else:
                wat[i, j] = 1
    return wat


"""***Step b: Key generation***"""


def keyGeneration(size):
    key = np.zeros(256, dtype=np.uint32)

    for i in range(len(key)):
        key[i] = secrets.randbelow(1000000001)

    seedGeneration = ""
    for i in range(len(key)):
        seedGeneration += str(key[i])

    with open('seed', 'wb') as seedGenerationFile:
        pickle.dump(seedGeneration, seedGenerationFile)
    return generateMatrixK(seedGeneration, size)


def generateMatrixK(seed, size):
    random.seed(int(seed))
    stringaK = format(random.randint(0, 2 ** (size * size)), '#0' + str(size * size + 2) + 'b')

    K = np.zeros((size, size), dtype=np.uint8)
    count = 2
    for i in range(size):
        for j in range(size):
            K[i, j] = int(stringaK[count])
            count += 1

    return K


"""***Step c: Logical XOR***"""


def xorWatermark(wat, key):
    np.logical_xor(wat, key, out=wat, where=1)


"""***Step d: Gray Code***"""


def grayDecoder(grayString):
    result = prec = grayString[0]

    for el in grayString[1:]:
        prec = str(
            int(el) ^ int(prec))
        result += prec

    return result


def grayEncoder(binaryString):
    result = prec = binaryString[0]

    for el in binaryString[1:]:
        result += str(int(el) ^ int(prec))
        prec = el

    return result

def graycode_bool_seq(seq):
    seq = np.array(seq, dtype=np.bool)
    seq_shift = np.hstack(([False], seq[:-1]))
    seq_graycode = np.logical_xor(seq, seq_shift)
    seq_graycode = np.array(seq_graycode, dtype=np.uint8)
    return seq_graycode


def graydecode_bool_seq(seq_graycode):
    out_seq = [seq_graycode[0]]
    for i in range(1, len(seq_graycode)):
        out_seq.append(np.logical_xor(out_seq[i-1], seq_graycode[i]))
    out_seq = np.array(out_seq, dtype=np.uint8)
    return out_seq

def ecencode_gray(watermark, fake=False, group_len=None):
    if fake:
        return watermark.copy()
    watermark_seq = watermark.copy().ravel().astype(np.bool)
    if group_len is None:
        watermark_gray = graycode_bool_seq(watermark_seq)
        return (watermark_gray.astype(np.uint8)).reshape(watermark.shape)
    else:
        groups = [watermark_seq[i:i+group_len]
                  for i in range(0, len(watermark_seq), group_len)]
        groups_gray = []
        for g_seq in groups:
            groups_gray.extend(graycode_bool_seq(g_seq))
        return np.array(groups_gray, dtype=np.uint8).reshape(watermark.shape)


def ecdecode_gray(watermark, fake=False, group_len=None):
    if fake:
        return watermark.copy()
    watermark_seq = watermark.copy().ravel().astype(np.bool)
    if group_len is None:
        new_watermark = graydecode_bool_seq(watermark_seq)
        return (new_watermark.astype(np.uint8)).reshape(watermark.shape)
    else:
        groups = [watermark_seq[i:i+group_len]
                  for i in range(0, len(watermark_seq), group_len)]
        groups_gray = []
        for g_seq in groups:
            groups_gray.extend(graydecode_bool_seq(g_seq))
        return np.array(groups_gray, dtype=np.uint8).reshape(watermark.shape)
    # out_seq = [watermark_seq[0]]
    # for i in range(1, len(watermark_seq)):
    #     out_seq.append(np.logical_xor(out_seq[i-1], watermark_seq[i]))
    # out_seq = np.array(out_seq)
    # return out_seq.reshape(watermark.shape)

def applyGrayCode(watermark):
    #stringatemp = ""
    stringares = ""
    watermarkSize = watermark.shape[0]
    for i in range(len(watermark)):
        #stringatemp = ""
        for j in range(len(watermark[0])):
            #stringatemp += str(watermark[i, j])
            stringares += str(watermark[i, j])
        #stringares += grayEncoder(stringatemp)

    #watermark = np.reshape(list(map(int, list(stringares))), (watermarkSize, watermarkSize))
    watermark = np.reshape(list(map(int, list(grayEncoder(stringares)))), (watermarkSize, watermarkSize))

    return watermark


def decodeGrayCode(watermark):
    #stringatemp = ""
    stringares = ""
    watermarkSize = watermark.shape[0]
    for i in range(len(watermark)):
        #stringatemp = ""
        for j in range(len(watermark[0])):
            #stringatemp += str(watermark[i, j])
            stringares += str(watermark[i, j])
        #stringares += grayDecoder(stringatemp)

    #watermark = np.reshape(list(map(int, list(stringares))), (watermarkSize, watermarkSize))
    watermark = np.reshape(list(map(int, list(grayDecoder(stringares)))), (watermarkSize, watermarkSize))

    return watermark

'''def applyGrayCode(watermark):
    stringa = ""
    watermarkSize = watermark.shape[0]
    for i in range(len(watermark)):
        for j in range(len(watermark[0])):
            stringa += str(watermark[i, j])

    watermark = np.reshape(list(map(int, list(grayEncoder(stringa)))), (watermarkSize, watermarkSize))

    return watermark


def decodeGrayCode(watermark):

    stringa = ""
    watermarkSize = watermark.shape[0]
    for i in range(len(watermark)):
        for j in range(len(watermark[0])):
            stringa += str(watermark[i, j])

    watermark = np.reshape(list(map(int, list(grayDecoder(stringa)))), (watermarkSize, watermarkSize))

    return watermark'''


"""***Watermarking Manipulation***"""


def watermarkManipulation(watermark, xor=True, grayCode=True):
    # Step a
    watermark = watermarkRounding(watermark)

    # Step b
    K = keyGeneration(watermark.shape[0])

    # Step c
    if xor:
        xorWatermark(watermark, K)

    # Step d
    if grayCode:
        watermark = applyGrayCode(watermark)
        #watermark = ecencode_gray(watermark)

    return watermark


"""### **STEP 2: Separation into blocks**"""


def divideImage(img, watermarkSize, channel):
    img2 = img[:, :, channel]
    imgW, imgH = img2.shape
    sizeBlock = int(8)
    blocks1 = np.array(
        [img2[i:i + sizeBlock, j:j + sizeBlock] for i in range(int(imgH * 0.00), int(imgH * 0.25), sizeBlock) for j in
         range(int(imgW * 0.00), int(imgW * 1.00), sizeBlock)], dtype=np.uint8)
    blocks2 = np.array(
        [img2[i:i + sizeBlock, j:j + sizeBlock] for i in range(int(imgH * 0.75), int(imgH * 1.00), sizeBlock) for j in
         range(int(imgW * 0.00), int(imgW * 1.00), sizeBlock)], dtype=np.uint8)
    blocksA = np.array(
        [img2[i:i + sizeBlock, j:j + sizeBlock] for i in range(int(imgH * 0.25), int(imgH * 0.75), sizeBlock) for j in
         range(int(imgW * 0.00), int(imgW * 0.25), sizeBlock)], dtype=np.uint8)
    blocksB = np.array(
        [img2[i:i + sizeBlock, j:j + sizeBlock] for i in range(int(imgH * 0.25), int(imgH * 0.75), sizeBlock) for j in
         range(int(imgW * 0.75), int(imgW * 1.00), sizeBlock)], dtype=np.uint8)
    blocks3 = copy.deepcopy(blocks1)
    #blocks3 = np.concatenate((blocksA, blocksB))
    blocks4 = np.array(
        [img2[i:i + sizeBlock, j:j + sizeBlock] for i in range(int(imgH * 0.25), int(imgH * 0.75), sizeBlock) for j in
         range(int(imgW * 0.25), int(imgW * 0.75), sizeBlock)], dtype=np.uint8)

    pos = 0
    jumpA = 0
    jumpB = 0
    for i in range(watermarkSize):
      for k in range(int(watermarkSize/2)):
        blocks3[pos] = blocksA[k+jumpA]
        pos += 1
  
      jumpA += int(watermarkSize/2)
      for k in range(int(watermarkSize/2)):
        blocks3[pos] = blocksB[k+jumpB]
        pos += 1 
      jumpB += int(watermarkSize/2)

    return [blocks1, blocks2, blocks3, blocks4]


"""### **STEP 3: Determinate Embedding Positions**"""


def embeddingPosition(watermark, perm=True):
    watermarkSize = watermark.shape[0]

    seedFile = open('seed', 'rb')
    seed = pickle.load(seedFile)
    seedFile.close
    watArray = np.reshape(watermark, (watermarkSize ** 2))

    if perm:
        random.seed(seed)
        #random.seed(0)
        random.shuffle(watArray)

    watermark = np.reshape(watArray, (watermarkSize, watermarkSize))

    return watermark


"""### **STEP 4: Embedding the watermark**"""


def embedding(areas, watermark, lamb):
    waterH, waterW = watermark.shape
    sizeBlock = 8

    for i in range(len(areas)):
        blocks = areas[i]
        counter = 0

        for j in range(waterW):
            for k in range(waterH):
                blocco = blocks[counter]
                counter += 1

                if watermark[j, k] == 1:
                    for z in range(sizeBlock):
                        for y in range(sizeBlock):
                            if blocco[z, y] + lamb >= 255:
                                blocco[z, y] = 255
                            else:
                                blocco[z, y] += lamb
                else:
                    for z in range(sizeBlock):
                        for y in range(sizeBlock):
                            if blocco[z, y] - lamb <= 0:
                                blocco[z, y] = 0
                            else:
                                blocco[z, y] -= lamb

    return areas


"""### **STEP 5: Recostruction**"""


def recostruction(areas, imgSize, watSize):
    img = np.zeros((imgSize, imgSize), dtype=np.uint8)
    blockSize = 8

    counter = 0
    for i in range(int(imgSize * 0.00), int(imgSize * 0.25), blockSize):
        for j in range(int(imgSize * 0.00), int(imgSize * 1.00), blockSize):
            img[i: i + blockSize, j: j + blockSize] = areas[0][counter]
            counter += 1

    counter = 0
    for i in range(int(imgSize * 0.75), int(imgSize * 1.00), blockSize):
        for j in range(int(imgSize * 0.00), int(imgSize * 1.00), blockSize):
            img[i: i + blockSize, j: j + blockSize] = areas[1][counter]
            counter += 1


    '''counter = 0
    for i in range(int(imgSize * 0.25), int(imgSize * 0.75), blockSize):
        for j in range(int(imgSize * 0.00), int(imgSize * 0.25), blockSize):
            img[i: i + blockSize, j: j + blockSize] = areas[2][counter]
            counter += 1

    for i in range(int(imgSize * 0.25), int(imgSize * 0.75), blockSize):
        for j in range(int(imgSize * 0.75), int(imgSize * 1.00), blockSize):
            img[i: i + blockSize, j: j + blockSize] = areas[2][counter]
            counter += 1'''

    jump = int(imgSize*0.25) - int(imgSize*0.00)
    counter = 0

    for i in range(int(imgSize*0.25), int(imgSize*0.75), blockSize):
      for j in range(int(imgSize*0.00), int(imgSize*0.25), blockSize):
        img[i : i+blockSize, j : j+blockSize] = areas[2][counter]
        counter += 1
      for j in range(int(imgSize*0.75), int(imgSize*1.00), blockSize):
        img[i : i+blockSize, j : j+blockSize] = areas[2][counter]
        counter += 1



    counter = 0
    for i in range(int(imgSize * 0.25), int(imgSize * 0.75), blockSize):
        for j in range(int(imgSize * 0.25), int(imgSize * 0.75), blockSize):
            img[i: i + blockSize, j: j + blockSize] = areas[3][counter]
            counter += 1

    return img


"""### **Step 6: Recomposition**"""


def recomposition(img, newChannel, channel):
    img[:, :, channel] = newChannel

    return img


"""## **Watermark Extraction**

***Normalized Cross Correlation***
"""


def ncc(wat, watEx):
    watSize = wat.shape[0]
    num = 0.0
    den = 0.0

    for i in range(watSize):
        for j in range(watSize):
            num += wat[i, j] * watEx[i, j]
            den += wat[i, j] ** 2

    ncc = num / den
    return ncc


"""***PSNR***"""


def psnr(img, imgWithWatermark):
    mse = np.mean((img - imgWithWatermark) ** 2)

    if (mse == 0):
        return 100

    maxPixel = 255.0
    psnrVal = 20 * math.log10(maxPixel / math.sqrt(mse))

    return psnrVal


"""**Reverse Permutation**"""


def reversePermutation(watermark, perm=True):
    seedFile = open('seed', 'rb')
    seed = pickle.load(seedFile)
    seedFile.close

    watSize = int(math.sqrt(watermark.shape[0]))
    Order = list(range(len(watermark)))

    if perm:
        random.seed(seed)
        #random.seed(0)
        random.shuffle(Order)

    originalList = [0] * len(watermark)
    for index, originalIndex in enumerate(Order):
        originalList[originalIndex] = watermark[index]

    return np.reshape(originalList, (watSize, watSize))


"""**Extraction**"""


def extractWatermark(blocksImg, blocksImgMarked, watSize, perm=True):
    blockSize = 8
    watermark = np.zeros(watSize ** 2, dtype=np.uint8)

    for i in range(len(blocksImg)):
        blocco = blocksImg[i]
        bloccoEmb = blocksImgMarked[i]
        P1 = 0.0
        P0 = 0.0
        for k in range(blockSize):
            for j in range(blockSize):
                if bloccoEmb[k, j] > blocco[k, j]:
                    P1 += 1.0 / (blockSize ** 2)
                else:
                    P0 += 1.0 / (blockSize ** 2)

        if P1 >= P0:
            watermark[i] = 1

    return reversePermutation(watermark, perm)



def extractAllWatermark(img, imgMarked, logo, channel=2, xor=True, grayCode=True, perm=True, filename="", typeReg=0, test=False):
    logoSize = logo.shape[0]
    nccMax = -1
    psnrMax = -1
    imgMarkedOriginal = copy.deepcopy(imgMarked)
    folderOut = "noneReg"
    # Step a
    logo = watermarkRounding(logo)
    # Step b
    watermarkExtracted = np.zeros((logoSize, logoSize), dtype=np.uint8)
    # Step Register
    if typeReg == 1:
        imgMarked = alignImages(imgMarked, img)
        folderOut = "RegClassic"
    elif typeReg == 2:
        imgMarked = rotateImg(imgMarked, img)
        folderOut = "RegOnlyAffine"
    # Step c
    areasImg = divideImage(copy.deepcopy(img), logoSize, channel)
    areasImgMarked = divideImage(copy.deepcopy(imgMarked), logoSize, channel)

    if test == False:
        plot_params = dict(cmap="gray", vmin=0, vmax=255, interpolation=None)
        plot_params_binary = dict(cmap="gray", vmin=0, vmax=1, interpolation=None)
        fig, ax = plt.subplots(nrows=2, ncols=4)
        fig.suptitle(filename)
        for _ax in ax[0][3:]:
            _ax.axis("off")
        for _ax in np.hstack((ax[0], ax[1])):
            _ax.set_xticks([])
            _ax.set_xticklabels([])
            _ax.set_yticks([])
            _ax.set_yticklabels([])
        ax[0][0].imshow(img, **plot_params)
        ax[0][0].set_title("original")
        ax[0][1].imshow(logo, **plot_params_binary)
        ax[0][1].set_title("watermark")
        ax[0][2].imshow(imgMarkedOriginal, **plot_params)
        ax[0][2].set_title("tested")
        positionName = ["Sup", "Inf", "Lateral", "Central"]

    # Step d
    for i in range(len(areasImg)):
        watEx = extractWatermark(areasImg[i], areasImgMarked[i], logoSize, perm)

        if grayCode:
            watEx = decodeGrayCode(watEx)
            #watEx = ecdecode_gray(watEx)

        if xor:
            seedFile = open('seed', 'rb')
            seed = pickle.load(seedFile)
            seedFile.close
            K = generateMatrixK(seed, logoSize)
            xorWatermark(watEx, K)

        nccWat = ncc(logo, watEx)
        if test == False:
            ax[1][i].imshow(watEx, **plot_params_binary)
            ax[1][i].set_title(positionName[i]+ "\n with ncc=\n" + str(round(nccWat,6)))


        if nccWat > nccMax:
            watermarkExtracted = watEx
            nccMax = nccWat
            psnrMax = psnr(img, imgMarked)
    # Step e
    '''if nccMax == -1:
        ax[0][3].set_title("No watermark found")
    else:
        ax[0][3].imshow(watermarkExtracted, **plot_params)
        ax[0][3].set_title("Watermark extracted")
        #showImage(watermarkExtracted * 255, "Watermark extracted with ncc = " + str(nccMax) + " e psnr = " + str(psnrMax))
    '''
    if test == False:
        fig.tight_layout()
        fig.savefig("img/decodeOutput/" + folderOut + "/" + filename + ".png")
        plt.close(fig)
        plt.close()
    return watermarkExtracted, nccMax, psnrMax

"""## Embedding Watermark

***Main Embedding watermark***
"""


def alignImages(im1, im2):
    # Convert images to grayscale
    im1Gray = cv2.cvtColor(im1, cv2.COLOR_BGR2GRAY)
    im2Gray = cv2.cvtColor(im2, cv2.COLOR_BGR2GRAY)

    # Detect ORB features and compute descriptors.
    orb = cv2.ORB_create(5000)
    keypoints1, descriptors1 = orb.detectAndCompute(im1Gray, None)
    keypoints2, descriptors2 = orb.detectAndCompute(im2Gray, None)

    # Match features.
    matcher = cv2.DescriptorMatcher_create(cv2.DESCRIPTOR_MATCHER_BRUTEFORCE_HAMMING)
    matches = matcher.match(descriptors1, descriptors2, None)

    # Sort matches by score
    matches.sort(key=lambda x: x.distance, reverse=False)

    # Remove not so good matches
    numGoodMatches = int(len(matches) * 0.15)
    matches = matches[:numGoodMatches]

    # Draw top matches
    imMatches = cv2.drawMatches(im1, keypoints1, im2, keypoints2, matches, None)
    cv2.imwrite("matches.jpg", imMatches)

    # Extract location of good matches
    points1 = np.zeros((len(matches), 2), dtype=np.float32)
    points2 = np.zeros((len(matches), 2), dtype=np.float32)

    for i, match in enumerate(matches):
        points1[i, :] = keypoints1[match.queryIdx].pt
        points2[i, :] = keypoints2[match.trainIdx].pt

    # Find homography
    h, mask = cv2.findHomography(points1, points2, cv2.RANSAC)

    # Use homography
    height, width, channels = im2.shape
    im1Reg = cv2.warpPerspective(im1, h, (width, height), flags=cv2.INTER_CUBIC)

    if np.abs(im2 - im1Reg).sum() < np.abs(im2 - im1).sum():
        #print("using registered")
        return im1Reg
    else:
        #print("using normal")
        return im1

def register(to_register, original):

    # Open the image files.
    img1_color = to_register.copy()
    img2_color = original.copy()

    # Convert to rgb.
    img1 = cv2.cvtColor(img1_color, cv2.COLOR_BGR2GRAY)
    img2 = cv2.cvtColor(img2_color, cv2.COLOR_BGR2GRAY)
    height, width = img2_color.shape[:2]

    # Create ORB detector with 5000 features. - number of point detected??
    orb_detector = cv2.ORB_create(5000)

    # Find keypoints and descriptors.
    # The first arg is the image, second arg is the mask
    #  (which is not reqiured in this case).
    kp1, d1 = orb_detector.detectAndCompute(img1, None)
    kp2, d2 = orb_detector.detectAndCompute(img2, None)

    # Match features between the two images.
    # We create a Brute Force matcher with
    # Hamming distance as measurement mode.
    matcher = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

    # Match the two sets of descriptors.
    matches = matcher.match(d1, d2)

    # Sort matches on the basis of their Hamming distance.
    matches.sort(key=lambda x: x.distance)

    # Take the top 90 % matches forward.
    matches = matches[:int(len(matches)*0.9)]
    no_of_matches = len(matches)

    # Define empty matrices of shape no_of_matches * 2.
    p1 = np.zeros((no_of_matches, 2))
    p2 = np.zeros((no_of_matches, 2))

    for i in range(len(matches)):
        p1[i, :] = kp1[matches[i].queryIdx].pt
        p2[i, :] = kp2[matches[i].trainIdx].pt

    # Find the homography matrix.
    homography, _ = cv2.findHomography(p1, p2, cv2.RANSAC)

    # Use this matrix to transform the
    # colored image wrt the reference image.
    transformed_img = cv2.warpPerspective(img1_color,
                                          homography, (width, height))
    if np.abs(original-transformed_img).sum() <= np.abs(original-to_register).sum():
        #print("using registered")
        return transformed_img
    else:
        #print("using normal")
        return to_register

def rotateImg(to_register, original):
    import imreg_dft as ird
    import imageio
    im0 = copy.deepcopy(original)
    im1 = copy.deepcopy(to_register)
    #result0 = ird.similarity(im0[:, :, 0], im1[:, :, 0], numiter=3)
    #result1 = ird.similarity(im0[:, :, 1], im1[:, :, 1], numiter=3)
    result2 = ird.similarity(im0[:, :, 2], im1[:, :, 2], numiter=3)
    #im1[:, :, 0] = result0['timg']
    #im1[:, :, 1] = result1['timg']
    im1[:, :, 2] = result2['timg']
    if result2['angle'] > 0.1 or result2['angle'] < -0.1:
        #print("using registered")
        return im1
    else:
        #print("using normal")
        return to_register


def embeddingWatermark(img, watermark, channel=2, lamb=5, xor=True, grayCode=True, perm=True):
    watermarkOriginal = copy.deepcopy(watermark)
    # Step 1
    watermark = watermarkManipulation(watermark, xor, grayCode)

    # Step 2
    areas = divideImage(img, watermark.shape[0], channel)

    # Step 3
    watEmbPos = embeddingPosition(copy.deepcopy(watermark), perm)

    # Step 4
    areas = embedding(areas, watEmbPos, lamb)

    # Step 5
    channelOut = recostruction(areas, img.shape[0], watermark.shape[0])
    #cv2.imwrite("img/imageBlueChannel.png", cv2.cvtColor(channelOut, cv2.COLOR_BGR2RGB))

    # Step 6
    imgOut = recomposition(copy.deepcopy(img), channelOut, channel)
    plot_params_binary = dict(cmap="gray", vmin=0, vmax=1, interpolation=None)
    fig, ax = plt.subplots(nrows=1, ncols=3)
    ax[0].imshow(img, **plot_params_binary)
    ax[0].set_title("original\nimage")
    ax[1].imshow(watermarkOriginal, **plot_params_binary)
    ax[1].set_title("original\nwatermark")
    ax[2].imshow(watermark, **plot_params_binary)
    ax[2].set_title("manipulated\nwatermark")
    fig.tight_layout()
    fig.savefig("img/encodeOutput/watermark_steps.png")
    plt.close(fig)
    plt.close()

    cv2.imwrite("img/encodeOutput/imageWithWatermark.png", cv2.cvtColor(imgOut, cv2.COLOR_BGR2RGB))
    return imgOut


"""# Main Section"""


def main_emb(imgPath, watPath, channel=2, lamb=5, xor=True, grayCode=True, perm=True, test=False):
    img = openImage(imgPath, True)
    #img = cv2.resize(img, (2048,2048),interpolation=cv2.INTER_CUBIC)
    wat = openImage(watPath)
    imgRes, watRes = resize(img, wat)
    imgOut = embeddingWatermark(copy.deepcopy(imgRes), copy.deepcopy(watRes), channel, lamb, xor, grayCode, perm)

    # imgCrop = cropLeftHighCorner(copy.deepcopy(imgOut))
    # extractAllWatermark(copy.deepcopy(imgRes), imgCrop, copy.deepcopy(watRes), channel)

    cv2.imwrite("img/encodeOutput/imageRes.png", cv2.cvtColor(imgRes, cv2.COLOR_BGR2RGB))
    cv2.imwrite("img/encodeOutput/watermarkRes.png", cv2.cvtColor(watRes, cv2.COLOR_BGR2RGB))


def main_dec(imgOriginalPath, watOriginalPath, imgInputEditPath, channel=2, xor=True, grayCode=True, perm=True, test=False):
    imgOriginal = openImage(imgOriginalPath, True)
    imgInputEdit = openImage(imgInputEditPath, True)
    watOriginal = openImage(watOriginalPath)

    imgH, imgW, c = imgOriginal.shape
    imgHEdit, imgWEdit, cEdit = imgInputEdit.shape

    if imgH != imgHEdit or imgW != imgWEdit:
        imgInputEdit = cv2.resize(imgInputEdit, (imgH,imgW),
                            interpolation=cv2.INTER_CUBIC)

    filename = os.path.splitext(os.path.basename(imgInputEditPath))[0]

    if test == True:
        watermarkExtracted, nccMax, psnrMax = extractAllWatermark(imgOriginal, copy.deepcopy(imgInputEdit), copy.deepcopy(watOriginal), channel, xor, grayCode, perm,
                        filename, typeReg=1, test=test)
        TEST1NCC[testcount, ntest] = nccMax
        TEST1PSNR[testcount, ntest] = psnrMax
        #watermarkExtracted, nccMax, psnrMax = extractAllWatermark(imgOriginal, copy.deepcopy(imgInputEdit), copy.deepcopy(watOriginal), channel, xor, grayCode,
        #                perm, filename, typeReg=2, test=test)
        #TEST2NCC[testcount, ntest] = nccMax
        #TEST2PSNR[testcount, ntest] = psnrMax
    else:
        extractAllWatermark(imgOriginal, copy.deepcopy(imgInputEdit), copy.deepcopy(watOriginal), channel, xor,
                            grayCode,
                            perm, filename, typeReg=1)


"""#EXAMPLE"""

parser = argparse.ArgumentParser()



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--decode', action='store_true',
                        help="decode watermark")
    parser.add_argument('-e', '--embedding', action='store_true',
                        help="embedding watermark")
    parser.add_argument('-t', '--test', action='store_true',
                        help="test")
    args = parser.parse_args()
    if args.decode:
        imgPath = "img/encodeOutput/imageRes.png"
        watPath = "img/encodeOutput/watermarkRes.png"
        d = "img/decodeInput"
        for path in os.listdir(d):
            full_path = os.path.join(d, path)
            main_dec(imgPath, watPath, full_path, channel=2, xor=True, grayCode=True, perm=True)
    elif args.embedding:
        imgPath = "img/encodeInput/img.png"
        watPath = "img/encodeInput/wat.png"
        main_emb(imgPath, watPath, channel=2, lamb=5, xor=True, grayCode=True, perm=True)
    elif args.test:
        import test
        imgPath = "img/encodeInput/img.png"
        watPath = "img/encodeInput/wat.png"
        imgPath2 = "img/encodeOutput/imageRes.png"
        watPath2 = "img/encodeOutput/watermarkRes.png"
        d = "img/decodeInput"
        nlen = 10
        global testcount, TEST1NCC, TEST1PSNR, TEST2NCC, TEST2PSNR
        TEST1NCC = np.zeros((nlen,24))
        TEST1PSNR = np.zeros((nlen, 24))
        TEST2NCC = np.zeros((nlen,24))
        TEST2PSNR = np.zeros((nlen, 24))
        import time
        start_time = time.time()
        for testcount in range(nlen):
            main_emb(imgPath, watPath, channel=2, lamb=5, xor=True, grayCode=True, perm=True, test=True)
            global ntest
            ntest = 0
            test.prepare_test("img/encodeOutput/imageWithWatermark.png", "img/decodeInput")
            for path in os.listdir(d):
                full_path = os.path.join(d, path)
                main_dec(imgPath2, watPath2, full_path, channel=2, xor=True, grayCode=True, perm=True,test=True)
                ntest = ntest + 1
            print(testcount)
            print("--- %s seconds ---" % (time.time() - start_time))

        import pandas as pd
        ## convert your array into a dataframe
        df1 = pd.DataFrame(TEST1NCC)
        df2 = pd.DataFrame(TEST1PSNR)
        #df3 = pd.DataFrame(TEST2NCC)
        #df4 = pd.DataFrame(TEST2PSNR)


        ## save to xlsx file
        filepath1 = 'TEST1NCC' + '.xlsx'
        filepath2 = 'TEST1PSNR' + '.xlsx'
        #filepath3 = 'TEST2NCC' + '.xlsx'
        #filepath4 = 'TEST2PSNR' + '.xlsx'

        df1.to_excel(filepath1, index=False)
        df2.to_excel(filepath2, index=False)
        #df3.to_excel(filepath3, index=False)
        #df4.to_excel(filepath4, index=False)



